/*

    author : s@if

*/

#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
using namespace std;

#define 		NIL 			-1
#define			INF 			1e9
#define         EPS             1e-9
#define         SAIF            main
#define		 	fi	 		    first
#define 		sec 			second
#define 		MAX 			INT_MAX
#define         pb              push_back
#define 		ll 			    long long
#define			MOD2 			100000007
#define 		PI 			    acos(-1.0)
#define			MOD 			1000000007
#define 		PLL 			pair<ll,ll>
#define 		PII			    pair<int,int>
#define 		ull 			unsigned long long
#define 		For(i,a,b) 		for(int i=a;i<=(int)b;i++)
typedef tree<int, null_type, less<int>, rb_tree_tag,
            tree_order_statistics_node_update> new_data_set;

//*find_by_order(k)  gives the kth element;
//order_of_key(item)   gives the index(number of element strictly less than item) of item;

inline int in() {int x; scanf("%d", &x); return x; }
bool Check(int N , int pos)	{	return (bool) (N & (1<<pos));}
int Set(int N, int pos) {	return N = N | (1<<pos);}
int Toggle(int N, int pos) {	return N = N ^ (1<<pos);}
int Off(int N, int pos) {if (Check(N,pos)==false) return N; else return Toggle(N,pos);}
ll TEN(int n) {if(n==0) return 1; return 10*TEN(n-1);}

int fx[]={+0,+0,+1,-1,-1,+1,-1,+1};    // King's move
int fy[]={-1,+1,+0,+0,+1,+1,-1,-1};
int hx[]={-2,-2,-1,+1,+2,+2,-1,+1};    // Knight's move
int hy[]={+1,-1,+2,+2,-1,+1,-2,-2};
int dx[]={+1,-1,+0,+0};
int dy[]={+0,+0,+1,-1};

const int MAXN = (int)2e2+9;

int N, M, a[MAXN][MAXN], Tree[4*MAXN][4*MAXN], seg[4*MAXN];

void build(int node, int l, int r, int strip)
{
    if(l>r) return;
    if(l==r)
    {
        seg[node] = a[strip][l]; return;
    }

    int mid = (l+r)>>1;
    build(node*2, l, mid, strip);
    build(node*2+1, mid+1, r, strip);

    seg[node] = max(seg[node*2], seg[node*2+1]);
}

void build(int node, int l, int r)
{
    if(l>r) return;
    if(l==r){
        build(1,1,M,l);
        for(int i=1; i<=3*M; i++)
        {
            Tree[node][i] = seg[i];
        }
        return;
    }
    int mid = (l+r)>>1;
    build(node*2, l, mid);
    build(node*2+1, mid+1, r);

    for(int i=1; i<=3*M; i++)
        Tree[node][i] = max(Tree[node*2][i], Tree[node*2+1][i]);
}

int query(int node, int l, int r, int y1, int y2, int pos)
{
    if(l>r || r<y1 || l>y2) return -INF;
    if(l>=y1 && r<=y2)
    {
        return Tree[pos][node];
    }

    int mid = (l+r)>>1;
    int ret1 = query(node*2, l, mid, y1, y2, pos);
    int ret2 = query(node*2+1, mid+1, r, y1, y2, pos);

    return max(ret1, ret2);
}

int query(int node, int l, int r, int x1, int x2, int y1, int y2)
{
    if(l>r || r<x1 || l>x2) return -INF;
    if(l>=x1 && r<=x2)
    {
        return query(1,1,M,y1,y2,node);
    }

    int mid = (l+r)>>1;
    int ret1 = query(node*2, l, mid, x1, x2, y1, y2);
    int ret2 = query(node*2+1, mid+1, r, x1, x2, y1, y2);
    return max(ret1, ret2);
}

void fin_update(int node, int l, int r, int y, int w, int pos)
{
    if(l>r || r<y || l>y) return;
    if(l==y && r==y)
    {
        Tree[pos][node] = w; return;
    }

    int mid = (l+r)>>1;
    fin_update(node*2, l, mid, y, w, pos);
    fin_update(node*2+1, mid+1, r, y, w, pos);

    Tree[pos][node] = max(Tree[pos][node*2], Tree[pos][node*2+1]);
}

void update(int node, int l, int r, int x, int y, int w)
{
    if(l>r || r<x || l>x) return;
    if(l==x && r==y)
    {
        fin_update(1,1,M,y,w,node); return;
    }

    int mid = (l+r)>>1;
    update(node*2, l, mid, x, y, w);
    update(node*2+1, mid+1, r, x, y, w);

    for(int i=1; i<=3*M; i++)
        Tree[node][i] = max(Tree[node*2][i], Tree[node*2+1][i]);
}

void solve(int cs)
{
    int i,j,k,l,m,n,p,q,x,y,u,v,w,r;

    cin>>N>>M;
    for(i=1; i<=N; i++)
    {
        for(j=1; j<=M; j++)
            cin>>a[i][j];
    }

    build(1,1,N);

    cin>>q;
    while(q--)
    {
        int x1, y1, x2, y2;
        cin>>k;
        if(k==1)
        {
            cin>>x1>>y1>>x2>>y2;
            cout<<query(1,1,N,x1,x2,y1,y2)<<endl;
        }
        else
        {
            cin>>x>>y>>w;
            update(1,1,N,x1,y,w);
        }
    }

    //printf("Case %d: ", cs);
    return;
}

int SAIF()
{
    int tc = 1, t = 0;

  //  cin>>tc;

    while(tc--){
        solve(++t);
    }

    return 0;
}

// read the question correctly (is y a vowel? what are the exact constraints?)
// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?)
